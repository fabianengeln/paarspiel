<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paarspiel</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #355C7D 0%, #6C5B7B 100%);
        }
        .container {
            text-align: center;
            padding: 2rem;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(192, 108, 132, 0.1);
            max-width: 600px;
            width: 90%;
            box-sizing: border-box;
            margin-top: 2rem;
            margin-bottom: 2rem;
        }
        h1 {
            color: #355C7D;
            margin-bottom: 1rem;
        }
        .question-box {
            min-height: 100px;
            margin: 2rem 0;
            padding: 1rem;
            background: #F67280;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: white;
            border: 2px solid #C06C84;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: center;
            margin-top: 2rem;
        }
        select {
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
            border: 2px solid #355C7D;
            border-radius: 25px;
            background: white;
            color: #355C7D;
            cursor: pointer;
            outline: none;
            width: 220px;
        }
        select:hover {
            border-color: #6C5B7B;
        }
        button {
            background: #355C7D;
            color: white;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
        }
        button:hover {
            background: #6C5B7B;
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
        }
        .heart {
            color: #C06C84;
            font-size: 1.5rem;
            margin: 0 0.5rem;
        }
        .answer-section {
            margin: 2rem 0;
            width: 100%;
            box-sizing: border-box;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            display: none;
        }
        .answer-section.visible {
            visibility: visible;
            opacity: 1;
            display: block;
        }
        .navigation-buttons {
            margin: 2rem 0;
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        .navigation-buttons button {
            min-width: 150px;
        }
        .next-content-btn {
            background: #355C7D;
        }
        .next-content-btn:hover {
            background: #6C5B7B;
        }
        .next-content-btn:disabled {
            background: #cccccc;
            opacity: 0.5;
            cursor: not-allowed;
        }
        .next-content-btn:disabled:hover {
            background: #cccccc;
            transform: none;
        }
        .next-player-btn {
            background: #C06C84;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .next-player-btn:hover {
            background: #F67280;
            transform: translateY(-2px);
        }
        .next-player-btn:disabled {
            background: #cccccc;
            opacity: 0.5;
            cursor: not-allowed;
        }
        .next-player-btn:disabled:hover {
            background: #cccccc;
            transform: none;
        }
        .end-game-btn {
            background: #000000;
        }
        .end-game-btn:hover {
            background: #333333;
        }
        textarea {
            width: 100%;
            min-height: 100px;
            padding: 1rem;
            margin: 1rem 0;
            border: 2px solid #355C7D;
            border-radius: 10px;
            font-size: 1rem;
            resize: vertical;
            box-sizing: border-box;
            background: white;
            color: #355C7D;
        }
        textarea:focus {
            outline: none;
            border-color: #6C5B7B;
        }
        textarea::placeholder {
            color: #C06C84;
        }
        .button-group {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1rem;
            flex-wrap: wrap;
        }
        .turn-indicator {
            color: #355C7D;
            font-size: 1.2rem;
            margin-bottom: 1rem;
            font-weight: bold;
        }
        .wheel-container {
            position: relative;
            width: 300px;
            height: 300px;
            margin: 2rem auto;
        }
        .wheel {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            position: relative;
            background: conic-gradient(
                #355C7D 0deg 120deg,
                #6C5B7B 120deg 240deg,
                #C06C84 240deg 360deg
            );
            transition: transform 3s cubic-bezier(0.17, 0.67, 0.12, 0.99);
            transform: rotate(0deg);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
        }
        .wheel::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            z-index: 2;
        }
        .wheel-text {
            position: absolute;
            top: 50%;
            left: 50%;
            color: white;
            font-weight: bold;
            font-size: 16px;
            text-align: center;
            width: 120px;
            transform-origin: center;
            pointer-events: none;
        }
        .wheel-text:nth-child(1) {
            transform: translate(-50%, -50%) rotate(60deg) translateY(-400%);
        }
        .wheel-text:nth-child(2) {
            transform: translate(-50%, -50%) rotate(180deg) translateY(-400%);
        }
        .wheel-text:nth-child(3) {
            transform: translate(-50%, -50%) rotate(300deg) translateY(-200%);
        }
        .wheel.selected {
            filter: brightness(1.2);
        }
        .spin-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            background: #F67280;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        .spin-button:hover {
            background: #C06C84;
        }
        .wheel-pointer {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 30px solid #F67280;
            z-index: 3;
        }
        .selected-category {
            display: none;  /* Hide the element completely */
        }
        .category-select {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            display: none;
        }
        .category-select.visible {
            visibility: visible;
            opacity: 1;
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Paarspiel <span class="heart">❤</span></h1>
        <div class="turn-indicator">
            {{ current_turn }} ist an der Reihe
        </div>
        <div class="wheel-container">
            <div class="wheel-pointer"></div>
            <div class="wheel" id="wheel">
                <div class="wheel-text">Frage</div>
                <div class="wheel-text">Mini-Aufgabe</div>
                <div class="wheel-text">Kompliment-Challenge</div>
            </div>
            <div class="spin-button" onclick="spinWheel()">Drehen</div>
        </div>
        <div class="question-box" id="questionBox">
            Du bist an der Reihe - dreh am Rad!
        </div>

        <!-- Navigation buttons moved here, directly below the question box -->
        <div class="navigation-buttons">
            <button onclick="getNewContent()" class="next-content-btn" id="nextContentBtn" disabled>Nächste Aufgabe</button>
            <button type="button" onclick="switchPlayer()" class="next-player-btn" id="nextPlayerBtn" disabled>Nächster Spieler</button>
            <button onclick="endGame()" class="end-game-btn">Spiel beenden</button>
        </div>

        <!-- Answer section moved here, below the navigation buttons -->
        <div class="answer-section" id="answerSection">
            <textarea id="answerInput" placeholder="{{ current_turn }}: Deine Antwort hier..." disabled></textarea>
        </div>

        <div class="controls">
            <select id="categorySelect" class="category-select" onchange="updateCategory()">
                <option value="all">Alle Kategorien</option>
            </select>
        </div>
    </div>

    <script>
        let currentCategory = 'all';
        let currentContentId = null;
        let currentContentType = null;
        let isSpinning = false;
        let hasSpun = false;
        let isSwitchingTurn = false;  // Flag to prevent double requests

        // Load categories when the page loads
        window.onload = async function() {
            try {
                const response = await fetch('/get_categories?type=question');
                const data = await response.json();
                const select = document.getElementById('categorySelect');
                
                // Add categories to dropdown
                data.categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category;
                    select.appendChild(option);
                });

                // Reset spin state for new turn
                hasSpun = false;
                updateSpinButton();

                // Add click event listener to next player button
                const nextPlayerBtn = document.getElementById('nextPlayerBtn');
                nextPlayerBtn.addEventListener('click', switchPlayer);
            } catch (error) {
                console.error('Fehler beim Laden:', error);
            }
        };

        function updateSpinButton() {
            const spinButton = document.querySelector('.spin-button');
            const nextPlayerBtn = document.getElementById('nextPlayerBtn');
            const nextContentBtn = document.getElementById('nextContentBtn');
            
            if (hasSpun) {
                spinButton.style.opacity = '0.5';
                spinButton.style.cursor = 'not-allowed';
                nextPlayerBtn.disabled = false;
                nextContentBtn.disabled = false;
            } else {
                spinButton.style.opacity = '1';
                spinButton.style.cursor = 'pointer';
                spinButton.textContent = 'Drehen';
                nextPlayerBtn.disabled = true;
                nextContentBtn.disabled = true;
            }
        }

        function updateCategory() {
            currentCategory = document.getElementById('categorySelect').value;
            getNewContent();
        }

        function getSelectedSection(degrees) {
            // Normalize degrees to 0-360
            degrees = degrees % 360;
            if (degrees < 0) degrees += 360;

            // Define the boundaries for each section relative to the pointer (0 degrees)
            // Section 0 (Frage) is centered at 0 degrees
            // Section 1 (Mini-Aufgabe) is centered at 120 degrees
            // Section 2 (Kompliment-Challenge) is centered at 240 degrees

            // Adjust degrees to align the center of the 'Frage' section with 0 for easier range checking
            // We need to shift the degrees by half the section width (60 degrees) relative to the pointer.
             let adjustedDegrees = (degrees + 60) % 360; // Shift so boundary between 2 and 0 is at 0

            // Determine section based on adjusted degrees
            if (adjustedDegrees >= 0 && adjustedDegrees < 120) return 0; // Frage
            if (adjustedDegrees >= 120 && adjustedDegrees < 240) return 1; // Mini-Aufgabe
            if (adjustedDegrees >= 240 && adjustedDegrees < 360) return 2; // Kompliment-Challenge

            return 0; // Default or fallback, should not be reached if logic is correct
        }

        function getTargetDegrees(sectionIndex) {
            // We want the center of the selected section to be at the top (0 degrees).
            // The center of section 0 (Frage) is initially at 60 degrees.
            // The center of section 1 (Mini-Aufgabe) is initially at 180 degrees.
            // The center of section 2 (Kompliment-Challenge) is initially at 300 degrees.
            // To bring the center of section N (initially at N*120 + 60 degrees) to the top,
            // we need to rotate the wheel by -(N*120 + 60) degrees.
            return -(sectionIndex * 120 + 60);
        }

        function spinWheel() {
            if (isSpinning || hasSpun) return;
            isSpinning = true;

            const wheel = document.getElementById('wheel');

            // Remove previous selection
            document.querySelectorAll('.wheel-text').forEach(section => {
                section.classList.remove('selected');
            });

            // 1. Randomly select the target section (0, 1, or 2)
            const selectedSection = Math.floor(Math.random() * 3);
            console.log(`spinWheel: Randomly selected section index: ${selectedSection}`);

            // 2. Calculate the exact degrees needed to bring the center of the selected section to the top (0 degrees)
            const finalDegrees = getTargetDegrees(selectedSection);
            console.log(`spinWheel: Calculated final degrees: ${finalDegrees}`);

            // 3. Add a large random spin amount (multiple of 360) to make it look like a random spin
            const randomBigSpin = 360 * (5 + Math.floor(Math.random() * 5)); // 5 to 9 full spins
            const totalDegreesToRotate = randomBigSpin + finalDegrees;
             console.log(`spinWheel: Total degrees to rotate (randomBigSpin + finalDegrees): ${totalDegreesToRotate}`);

            // Set up the animation
            wheel.style.transition = 'transform 3s cubic-bezier(0.17, 0.67, 0.12, 0.99)';
            wheel.style.transform = `rotate(${totalDegreesToRotate}deg)`;


             setTimeout(() => {
                  // Use the actual final angle to determine the selected section
                 // const selectedSection = getSelectedSection(actualFinalDegrees);

                 const selectedSectionDiv = wheel.querySelector(`.wheel-text:nth-child(${selectedSection + 1})`);
                 if (selectedSectionDiv) {
                      selectedSectionDiv.classList.add('selected');
                 }

                 isSpinning = false;
                 hasSpun = true;
                 updateSpinButton();

                 // Set the current content type based on the selected section
                 const contentTypes = ['question', 'mini_task', 'compliment'];
                 currentContentType = contentTypes[selectedSection];
                 updateNextContentButton();

                 // Call getNewContent directly after spin completes
                 getNewContent();

             }, 3000); // Match the animation duration
        }

        function updateNextContentButton() {
            const button = document.getElementById('nextContentBtn');
            if (currentContentType === 'question') {
                button.textContent = 'Nächste Frage';
            } else if (currentContentType === 'mini_task') {
                button.textContent = 'Nächste Mini-Aufgabe';
            } else if (currentContentType === 'compliment') {
                button.textContent = 'Nächstes Kompliment';
            }
        }

        function switchTurn() {
            if (isSwitchingTurn) return;  // Prevent multiple requests
            isSwitchingTurn = true;

            fetch('/switch_turn', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update UI with new turn
                    document.querySelector('.turn-indicator').textContent = `Am Zug: ${data.current_turn}`;
                    // Reset answer section
                    document.querySelector('.answer-section').classList.remove('visible');
                    document.querySelector('textarea').value = '';
                    // Get new content
                    getContent();
                } else {
                    console.error('Error switching turn:', data.error);
                }
            })
            .catch(error => {
                console.error('Error:', error);
            })
            .finally(() => {
                isSwitchingTurn = false;  // Reset flag after request completes
            });
        }

        async function switchPlayer() {
            console.log('switchPlayer called');
            
            if (!hasSpun) {
                console.log('hasSpun is false');
                return;
            }

            const nextPlayerBtn = document.getElementById('nextPlayerBtn');
            nextPlayerBtn.disabled = true;
            
            try {
                console.log('Sending request to server');
                
                const response = await fetch('/switch_turn', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    credentials: 'same-origin'
                });

                console.log('Received response from server');
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Response data:', data);

                if (data.status === 'error') {
                    throw new Error(data.message || 'Failed to switch turns');
                }

                // Update the turn indicator with the new player name
                const turnIndicator = document.querySelector('.turn-indicator');
                if (data.current_turn) {
                    turnIndicator.textContent = `${data.current_turn} ist an der Reihe`;
                }
                
                // Reset the game state for the next player
                resetGameState();
                
                // Reload the page to ensure clean state
                window.location.reload();
            } catch (error) {
                console.error('Error in switchPlayer:', error);
                nextPlayerBtn.disabled = false;
                // Show error to user
                document.getElementById('questionBox').textContent = 'Fehler beim Spielerwechsel. Bitte versuche es erneut.';
            }
        }

        function resetGameState() {
            // Reset all game state variables
            hasSpun = false;
            currentContentId = null;
            currentContentType = null;
            
            // Reset UI elements
            document.getElementById('questionBox').textContent = 'Du bist an der Reihe - dreh am Rad!';
            document.getElementById('answerInput').value = '';
            document.getElementById('answerSection').classList.remove('visible');
            document.getElementById('categorySelect').classList.remove('visible');
            
            // Reset wheel
            const wheel = document.getElementById('wheel');
            wheel.style.transition = 'none';
            wheel.style.transform = 'rotate(0deg)';
            setTimeout(() => {
                wheel.style.transition = 'transform 3s cubic-bezier(0.17, 0.67, 0.12, 0.99)';
            }, 50);
            
            // Update buttons
            updateSpinButton();
            updateNextContentButton();
        }

        async function getNewContent() {
            console.log('getNewContent called');
            if (!hasSpun) {
                console.log('getNewContent: hasSpun is false, returning.');
                return; // Prevent action if wheel hasn't been spun
            }

            // Save current answer if there is one and content type was 'question'
            const answerInput = document.getElementById('answerInput');
            if (currentContentId && currentContentType === 'question') {
                 console.log('getNewContent: Saving answer before getting new content.');
                await saveAnswer();
            }

            try {
                console.log(`getNewContent: Fetching content for category=${currentCategory}, type=${currentContentType}`);
                const response = await fetch(`/get_content?category=${encodeURIComponent(currentCategory)}&type=${encodeURIComponent(currentContentType)}`);
                
                if (!response.ok) {
                     console.error('getNewContent: Fetch failed with status', response.status);
                     throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('getNewContent: Received data', data);
                
                const questionBox = document.getElementById('questionBox');
                const turnIndicator = document.querySelector('.turn-indicator');
                let playerName = 'Spieler'; // Default if name cannot be found

                if (turnIndicator && turnIndicator.textContent) {
                    // Extract player name from the turn indicator text
                    const match = turnIndicator.textContent.match(/(.*?) ist an der Reihe/);
                    if (match && match[1]) {
                        playerName = match[1].trim();
                    }
                }

                if (questionBox) {
                    questionBox.textContent = `${playerName}: ${data.text}`; // Set the text content with player name
                }
                
                currentContentId = data.id;
                currentContentType = data.type;
                
                // Show/hide elements based on content type
                const categorySelect = document.getElementById('categorySelect');
                const answerSection = document.getElementById('answerSection');
                
                if (data.type === 'question') {
                    console.log('getNewContent: Content type is question, showing category select and answer section.');
                    if (categorySelect) categorySelect.classList.add('visible');
                    if (answerSection) answerSection.classList.add('visible');
                    if (answerInput) answerInput.disabled = false;
                } else {
                    console.log(`getNewContent: Content type is ${data.type}, hiding category select and answer section.`);
                    if (categorySelect) categorySelect.classList.remove('visible');
                    if (answerSection) answerSection.classList.remove('visible');
                    if (answerInput) {
                         answerInput.disabled = true;
                         answerInput.value = '';
                    }
                }

                // Update the next content button text
                updateNextContentButton();
                
                // The switchPlayer logic should handle page reload after saving answer
                // or explicitly when Next Player button is clicked.

            } catch (error) {
                console.error('getNewContent: Error fetching content:', error);
                const questionBox = document.getElementById('questionBox');
                 if (questionBox) {
                    questionBox.textContent = 'Fehler beim Laden. Bitte versuche es erneut.';
                 }
            }
        }

        async function saveAnswer() {
            const answerText = document.getElementById('answerInput').value.trim();
            if (!answerText || !currentContentId) return;

            try {
                const response = await fetch('/save_answer', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        question_id: currentContentId,
                        answer: answerText
                    })
                });
                const data = await response.json();
                if (data.status === 'success') {
                    document.getElementById('answerInput').value = '';
                    document.getElementById('answerInput').disabled = true;
                    currentContentId = null;
                    // Reload the page to update the turn indicator and reset spin state
                    window.location.reload();
                }
            } catch (error) {
                console.error('Fehler beim Speichern:', error);
            }
        }

        function endGame() {
            // Save the last answer before ending the game
            if (currentContentId) {
                saveAnswer().then(() => {
                    window.location.href = '/summary';
                });
            } else {
                window.location.href = '/summary';
            }
        }
    </script>
</body>
</html> 